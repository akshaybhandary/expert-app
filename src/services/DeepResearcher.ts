import type { DeepResearchConfig, ResearchProgress } from '../types';
import { AIService } from './AIService';

export class DeepResearcher {
  private aiService: AIService;
  private defaultModels = [
    { name: 'GPT-4 Turbo', id: 'openai/gpt-4-turbo' },
    { name: 'Claude 3.5 Sonnet', id: 'anthropic/claude-3.5-sonnet' },
    { name: 'Llama 3.1 70B', id: 'meta-llama/llama-3.1-70b-instruct' },
    { name: 'Gemini 1.5 Pro', id: 'google/gemini-pro-1.5' }
  ];

  constructor(aiService: AIService) {
    this.aiService = aiService;
  }

  async conductResearch(
    query: string,
    config: DeepResearchConfig,
    onProgressUpdate?: (progress: ResearchProgress[]) => void
  ): Promise<string> {
    const {
      models = this.defaultModels.map(m => m.id),
      maxTokens = 2048,
      temperature = 0.7,
      systemPrompt = 'You are a research assistant. Provide a detailed, academic-style analysis of the subject with specific insights and actionable recommendations. Structure your response with clear headings and bullet points.',
      includeProgress = true
    } = config;

    const researchModels = this.defaultModels.filter(model => 
      models.includes(model.id)
    );

    if (researchModels.length === 0) {
      throw new Error('No valid models specified for research');
    }

    let progressState: ResearchProgress[] = researchModels.map(model => ({
      id: model.id,
      model: model.name,
      status: 'pending'
    }));

    if (onProgressUpdate && includeProgress) {
      onProgressUpdate([...progressState]);
    }

    let fullReport = `# üìã Comprehensive Analysis Report\n\n**Subject:** ${query}\n\n**Research Date:** ${new Date().toLocaleDateString()}\n\n---\n\n`;
    
    const results: Array<{ model: string; content: string; error?: string }> = [];

    for (let i = 0; i < researchModels.length; i++) {
      const model = researchModels[i];
      
      // Update progress to processing
      progressState = progressState.map(p => 
        p.id === model.id ? { ...p, status: 'processing' } : p
      );
      
      if (onProgressUpdate && includeProgress) {
        onProgressUpdate([...progressState]);
      }

      try {
        const response = await this.aiService.sendMessage(query, {
          model: model.id,
          maxTokens,
          temperature,
          systemPrompt: `${systemPrompt}\n\nProvide your analysis from the perspective of ${model.name}. Focus on unique insights that complement other AI perspectives. Use web search to find current, relevant information to support your analysis.`,
          enableWebSearch: true
        });

        results.push({
          model: model.name,
          content: response
        });

        // Update progress to completed
        progressState = progressState.map(p => 
          p.id === model.id ? { ...p, status: 'completed', content: response } : p
        );

      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        console.error(`Error with ${model.name}:`, error);
        
        results.push({
          model: model.name,
          content: '',
          error: errorMessage
        });

        // Update progress to error
        progressState = progressState.map(p => 
          p.id === model.id ? { ...p, status: 'error' } : p
        );
      }

      if (onProgressUpdate && includeProgress) {
        onProgressUpdate([...progressState]);
      }

      // Add delay between requests to avoid rate limiting
      if (i < researchModels.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // Compile the full report
    for (const result of results) {
      if (result.error) {
        fullReport += `## ‚ùå ${result.model} Analysis\n\n*Error: ${result.error}*\n\n---\n\n`;
      } else {
        fullReport += `## ü§ñ ${result.model} Analysis\n\n${result.content}\n\n---\n\n`;
      }
    }

    // Add synthesis section
    const successfulResults = results.filter(r => !r.error);
    if (successfulResults.length > 1) {
      fullReport += await this.generateSynthesis(query, successfulResults, {
        maxTokens,
        temperature: 0.8,
        systemPrompt: 'You are a research synthesizer. Analyze the provided AI responses and create a comprehensive synthesis that identifies common themes, conflicting viewpoints, and provides a balanced conclusion.'
      });
    }

    // Add summary
    fullReport += `\n## üéØ Research Summary\n\n`;
    fullReport += `This comprehensive analysis was generated by consulting ${successfulResults.length} AI model${successfulResults.length !== 1 ? 's' : ''} `;
    fullReport += `to provide diverse perspectives on: **${query}**\n\n`;
    
    if (results.some(r => r.error)) {
      const errorCount = results.filter(r => r.error).length;
      fullReport += `‚ö†Ô∏è Note: ${errorCount} model${errorCount !== 1 ? 's' : ''} encountered errors during analysis.\n\n`;
    }

    fullReport += `*Research completed at ${new Date().toLocaleTimeString()}*`;

    return fullReport;
  }

  private async generateSynthesis(
    originalQuery: string,
    results: Array<{ model: string; content: string }>,
    config: { maxTokens: number; temperature: number; systemPrompt: string }
  ): Promise<string> {
    const synthesisPrompt = `Original Query: "${originalQuery}"\n\nAI Model Responses:\n\n` +
      results.map((r, i) => `### Response ${i + 1} (${r.model}):\n${r.content}\n`).join('\n') +
      '\n\nPlease provide a synthesis that:\n' +
      '1. Identifies key themes and patterns across responses\n' +
      '2. Highlights areas of agreement and disagreement\n' +
      '3. Provides a balanced, comprehensive conclusion\n' +
      '4. Suggests actionable next steps based on the collective insights';

    try {
      const synthesis = await this.aiService.sendMessage(synthesisPrompt, {
        model: 'anthropic/claude-3.5-sonnet', // Use a reliable model for synthesis
        maxTokens: config.maxTokens,
        temperature: config.temperature,
        systemPrompt: config.systemPrompt,
        enableWebSearch: true
      });

      return `## üîÑ Cross-Model Synthesis\n\n${synthesis}\n\n---\n\n`;
    } catch (error) {
      console.error('Error generating synthesis:', error);
      return `## üîÑ Cross-Model Synthesis\n\n*Unable to generate synthesis due to API error.*\n\n---\n\n`;
    }
  }

  getAvailableModels() {
    return [...this.defaultModels];
  }

  updateDefaultModels(models: Array<{ name: string; id: string }>) {
    this.defaultModels = [...models];
  }
}